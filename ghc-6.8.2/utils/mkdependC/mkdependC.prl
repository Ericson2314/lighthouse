#
# This perl script template assumes that definitions for
# the following variables are prepended:
#
# DEFAULT_TMPDIR CPP BUILDPLATFORM
#
# ToDo: strip out all the .h junk
#
($Pgm = $0) =~ s/.*\/([^\/]+)$/\1/;
$Usage  = "usage: $Pgm: not done yet\n";

$Status  = 0; # just used for exit() status
$Verbose = 0;
$Dashdashes_seen = 0;

$Begin_magic_str = "# DO NOT DELETE: Beginning of C dependencies";
$End_magic_str = "# DO NOT DELETE: End of C dependencies";
$Obj_suffix = 'o';
@Defines = ();
$Include_dirs = '';
$Makefile = '';
@Src_files = ();
@File_suffix = ();
$baseName='';
$ignore_output='> /dev/null';

if ( ${BUILDPLATFORM} eq "i386-unknown-mingw32" ) {
    # Assuming the underlying perl uses cmd to exec system() calls.
    $ignore_output = ">nul";
}

if ( $ENV{'TMPDIR'} ) { # where to make tmp file names
    $Tmp_prefix = $ENV{'TMPDIR'} . "/mkdependC$$";
} else {
    $Tmp_prefix ="${DEFAULT_TMPDIR}/mkdependC$$";
    $ENV{'TMPDIR'} = "${DEFAULT_TMPDIR}"; # set the env var as well
}

$tempfile = '';

sub quit_upon_signal { 
  if (-f $tempfile) {
	print STDERR "Deleting $tempfile .. \n"; 
	unlink $tempfile;
   }
}
$SIG{'INT'}  = 'quit_upon_signal';
$SIG{'QUIT'} = 'quit_upon_signal';

&mangle_command_line_args();

if ( ! $Makefile && -f 'makefile' ) {
    $Makefile = 'makefile';
} elsif ( ! $Makefile && -f 'Makefile') {
    $Makefile = 'Makefile';
} elsif ( ! $Makefile) {
    die "$Pgm: no makefile or Makefile found\n";
}

@Depend_lines = ();

print STDERR "Include_dirs=$Include_dirs\n" if $Verbose;

foreach $sf (@Src_files) {
    # just like lit-inputter
    # except it puts each file through CPP and
    # a de-commenter (not implemented);
    # builds up @Depend_lines
    print STDERR "Here we go for source file: $sf\n" if $Verbose;
    ($baseName = $sf) =~ s/\.(c|hc)$//;

    &slurp_file($sf, 'fh00');
}

# Tiresome EOL termination issues
if ( ${BUILDPLATFORM} eq "i386-unknown-mingw32" ) {
    $Begin_magic_str = $Begin_magic_str . "\r\n";
    $End_magic_str = $End_magic_str . "\r\n";
} else {
    $Begin_magic_str = $Begin_magic_str . "\n";
    $End_magic_str = $End_magic_str . "\n";
}

# OK, mangle the Makefile
unlink("$Makefile.bak");
rename($Makefile,"$Makefile.bak");
# now copy Makefile.bak into Makefile, rm'ing old dependencies
# and adding the new
open(OMKF,"< $Makefile.bak") || die "$Pgm: can't open $Makefile.bak: $!\n";
open(NMKF,"> $Makefile") || die "$Pgm: can't open $Makefile: $!\n";
binmode(OMKF);	# Do not add stupid ^M's to the output on Win32
binmode(NMKF);	# Do not add stupid ^M's to the output on Win32

select(NMKF);
$_ = <OMKF>;
while ($_ && $_ ne $Begin_magic_str) { # copy through, 'til Begin_magic_str
    print $_;
    $_ = <OMKF>;
}
while ($_ && $_ ne $End_magic_str) { # delete 'til End_magic_str
    $_ = <OMKF>;
}
# insert dependencies
print $Begin_magic_str;
print @Depend_lines;
print $End_magic_str;
while (<OMKF>) { # copy the rest through
    print $_;
}
close(NMKF);
close(OMKF);
exit 0;

sub mangle_command_line_args {
    while($_ = $ARGV[0]) {
	shift(@ARGV);

	if ( /^--$/ ) {
	    $Dashdashes_seen++;

	} elsif ( /^(-optc)?(-D.*)/ ) { # recognized wherever they occur
	    push(@Defines, $2);
	} elsif ( /^(-optc)?(-I.*)/ ) {
	    $Include_dirs .= " $2";

	} elsif ($Dashdashes_seen != 1) { # not between -- ... --
	    if ( /^-v$/ ) {
		$Verbose++;
	    } elsif ( /^-f/ ) {
		$Makefile	= &grab_arg_arg($_);
	    } elsif ( /^-o/ ) {
		$Obj_suffix	= &grab_arg_arg($_);
	    } elsif ( /^-s/ ) {
		local($suff)	=  &grab_arg_arg($_);
		push(@File_suffix, $suff);
	    } elsif ( /^-bs/ ) {
		$Begin_magic_str = &grab_arg_arg($_);
	    } elsif ( /^-es/ ) {
		$End_magic_str = &grab_arg_arg($_);
	    } elsif ( /^-w/ ) {
		$Width	= &grab_arg_arg($_);
	    } elsif ( /^-/ ) {
		print STDERR "$Pgm: unknown option ignored: $_\n";
	    } else {
		push(@Src_files, $_);
	    }

	} elsif ($Dashdashes_seen == 1) { # where we ignore unknown options
	    push(@Src_files,$_) if ! /^-/;
	}
    }
}

sub grab_arg_arg {
    local($option) = @_;
    local($rest_of_arg);
    
    ($rest_of_arg = $option) =~ s/^-.//;

    if ($rest_of_arg) {
	return($rest_of_arg);
    } elsif ($#ARGV >= 0) {
	local($temp) = $ARGV[0]; shift(@ARGV); 
	return($temp);
    } else {
	die "$Pgm: no argument following $option option\n";
    }
}

sub slurp_file { # follows an example in the `open' item in perl man page
    local($fname,$fhandle) = @_;
    local($depend,$dep); # tmp
    local(@Deps);

    $fhandle++; # a string increment

    $fname = &tidy_dir_names($fname);

    ($tempfile = $fname) =~ s/\.[^\.]*$/\.d/;
    $tempfile =~ s|.*/([^/]+)$|$1|g;

    # ${CPP} better be 'gcc -E', or the -x option will fail...
    # ..and the -MM & -MMD.
    $result = system("${CPP} -MM -MMD $Include_dirs @Defines -x c $fname $ignore_output");
 
    if ($result != 0) {
        # On the cheesy side..we do want to know what went wrong, so
	# re-run the command.
	$result = system("${CPP} -MM -MMD $Include_dirs @Defines -x c $fname ");
	if ($result != 0) {
	   unlink($tempfile);
   	   exit($result);
        }
    };

    local($dep_contents)='';
    local($deps)='';
    open($fhandle, $tempfile) || die "$Pgm: Can't open $tempfile: $!\n";

    while (<$fhandle>) {
       chop;
       $dep_contents .= $_;
    }
    ($deps = $dep_contents) =~ s|^[^:]+:(.*)$|$1|g;
    $deps =~ s| \\| |g;
    
    @Deps = split(/ +/, $deps);
    
    $depend = "$baseName.$Obj_suffix";
    foreach $suff (@File_suffix) {
	 $depend .= " $baseName.${suff}_$Obj_suffix";
    }
    
    foreach $dep (@Deps) {
    	push(@Depend_lines, "$depend: $dep\n") if $dep ne '';
    }

    close($fhandle);
    unlink($tempfile);
    $tempfile = '';  # for quit_upon_signal
}

sub tidy_dir_names { # rm various pernicious dir-name combinations...
    local($str) = @_;

    $str =~ s|/[^/.][^/]*/\.\.||g;	# nuke: /<dir>/..
    $str =~ s|/\.[^.][^/]*/\.\.||g;	# nuke: /./.. (and others)
    $str =~ s|"||g;
    $str =~ s| \./| |;
    $str;
}
